<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>threejs</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
  <!-- åŠ åœ¨ <head> è£¡å³å¯ -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.skypack.dev/three@0.150.1"
  }
}
</script>

</head>
<body>
  <!-- ğŸš¨ è¢å¹•ä¸­å¤®è­¦å‘Šè¨Šæ¯ -->
  <div id="warning" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);
       background:red;color:white;padding:10px 20px;font-size:20px;font-weight:bold;
       border-radius:5px;display:none;z-index:1000;">
  </div>

  <!-- ğŸ“ˆ å³ä¸Šè³‡è¨Šé¡¯ç¤ºå€ -->
  <div style="position:absolute;top:10px;right:10px;z-index:10;font-family:monospace;font-size:16px;">
    <div id="timeDisplay" style="margin-bottom:8px;background:rgba(0,0,0,0.6);color:white;
         padding:8px 12px;border-radius:5px;">
      æ¨¡æ“¬ç§’æ•¸: 0.00s
    </div>
    <div id="etaDisplay" style="margin-bottom:8px;background:rgba(0,0,0,0.6);color:white;
         padding:8px 12px;border-radius:5px;">
      é ä¼°é€²å…¥è­¦ç¤ºå€åŸŸæ™‚é–“: -- s
    </div>
    <div id="brakeDisplay" style="margin-bottom:8px;background:rgba(0,0,0,0.6);color:white;
         padding:8px 12px;border-radius:5px;">
      ç¸½ç…åœè·é›¢: -- m<br>
      ç¸½ç…åœæ™‚é–“: -- s
    </div>
    <div id="formulaHUD" style="margin-bottom:8px;background:rgba(0,0,0,0.6);color:white;
         padding:8px 12px;border-radius:5px;display:none;">
      <!-- é¡¯ç¤º t_entry / t_stop -->
    </div>
    <div id="resultHUD" style="background:rgba(0,128,0,0.8);color:white;padding:8px 12px;
         border-radius:5px;font-size:18px;font-weight:bold;display:none;">
      <!-- æˆåŠŸæˆ–å¤±æ•—è¨Šæ¯ -->
    </div>
  </div>

  <!-- ğŸ•¹ å·¦ä¸‹ï¼šæ§åˆ¶é¢æ¿ -->
  <div style="position:absolute;bottom:10px;left:10px;z-index:10;font-family:monospace;font-size:16px;">
    <!-- ğŸ® æ§åˆ¶æŒ‰éˆ• -->
    <div style="margin-bottom:10px;">
      <button id="playBtn">â–¶ æ’­æ”¾</button>
      <button id="pauseBtn">â¸ æš«åœ</button>
      <button id="resetBtn">ğŸ”„ é‡è£½</button>
    </div>

    <!-- ğŸš— è»Šé€Ÿè¼¸å…¥ -->
    <div style="margin-bottom:10px;background:rgba(255,255,255,0.9);padding:10px;border-radius:5px;">
      <label>è»Šé€Ÿ v (m/s)ï¼š</label>
      <input id="speedInput" type="number" step="0.1" value="16.67" style="width:60px;" />
      <button id="setSpeedBtn">è¨­å®š</button>
    </div>

    <!-- ğŸ§â€â™‚ï¸ è¡Œäººè·¯ç·šåˆ‡æ› -->
    <div style="margin-bottom:10px;">
      <label><input type="radio" name="pedestrianRoute" value="default" checked> 1è·¯ç·š</label><br>
      <label><input type="radio" name="pedestrianRoute" value="object"> 2è·¯ç·š</label><br>
      <label><input type="radio" name="pedestrianRoute" value="wander"> 3è·¯ç·š</label>
    </div>

    <!-- ğŸ§­ å·¦ä¸‹è§’é€Ÿåº¦ HUD (km/h) -->
    <div id="speedHUD" style="background:rgba(0,0,0,0.6);color:white;padding:8px 12px;
         border-radius:5px;">
      é€Ÿåº¦: 0â€¯km/h
    </div>
  </div>

  <!-- ğŸ¨ å³ä¸‹ï¼šé€Ÿåº¦é¡è‰²åœ–ä¾‹ -->
  <div id="speedLegend" style="position:absolute;bottom:10px;right:10px;background:rgba(0,0,0,0.7);
       color:white;padding:10px;border-radius:10px;font-family:monospace;font-size:14px;line-height:1.5;z-index:10;">
    <div><span style="color:#00ffff">â—</span> &lt; 10 </div>
    <div><span style="color:#00ff00">â—</span> &lt; 20</div>
    <div><span style="color:#ffff00">â—</span> &lt; 30</div>
    <div><span style="color:#ffa500">â—</span> &lt; 40</div>
    <div><span style="color:#ff0000">â—</span> &lt; 50</div>
    <div><span style="color:#8b0000">â—</span> â‰¥ 50 </div>
  </div>

  <!-- ğŸ”Š éŸ³æ•ˆèˆ‡ç´…æ¡† -->
  <audio id="beepSfx" src="./beep-beep-beep-beep-80262.mp3" preload="auto"></audio>
  <audio id="voiceSfx" src="./è«‹æ³¨æ„å‰æ–¹è¡Œäºº.mp3" preload="auto"></audio>

  <div id="redFrame" style="position:fixed;inset:0;border:8px solid rgba(255,0,0,0);
       pointer-events:none;z-index:999;"></div>
  <script type="module">  
    import * as THREE from 'https://esm.sh/three@0.150.1';
import { GLTFLoader } from 'https://esm.sh/three@0.150.1/examples/jsm/loaders/GLTFLoader.js';
/* 1. è¼‰å…¥åŸå§‹åº§æ¨™ */
const raw = await (await fetch('./path_587.json')).json();

/* 2. è¨ˆç®—å¹³ç§»é‡ï¼šæŠŠç¬¬ä¸€é»æ‹‰åˆ°æƒ³è¦çš„èµ·é» (0,0,20) */
const first = raw[0];                            // {x:214.7, y:0.1, z:797.05}
const targetStart = new THREE.Vector3(0, 0.1, 0);
const delta = new THREE.Vector3(
  targetStart.x - first.x,
  targetStart.y - first.y,
  targetStart.z - first.z
);
// å…ˆæ”¾åˆ°æª”é ­å€åŸŸ
let currPedPos = new THREE.Vector3();   // â† æ–°å¢ï¼Œåªå­˜ã€Œé€™ä¸€å¹€ã€çš„è¡Œäººä½ç½®

/* 3â€‘a. è½‰æˆ Vector3 ä¸¦å¹³ç§»åˆ° (0,0.1,20) */
/* -------- è·¯å¾‘ 1ï¼ˆé è¨­ï¼‰ -------- */
const path = raw.map(p =>
  new THREE.Vector3(p.x + delta.x, p.y + delta.y, p.z + delta.z)
);
const targetStart2 = new THREE.Vector3(1, 0.1, 0);  // ä½ æƒ³è®“ç¬¬äºŒæ¢è·¯ç·šèµ·é»ç§»åˆ°çš„åº§æ¨™

const first2 = raw.find(p => p.z >= 800);  // æ‰¾ path2 çš„ç¬¬ä¸€å€‹é»
const delta2 = new THREE.Vector3(
  targetStart2.x - first2.x,
  targetStart2.y - first2.y,
  targetStart2.z - first2.z
);

/* -------- è·¯å¾‘ 2ï¼ˆ221~228 ä¹‹é–“ï¼‰ -------- */
const path2 = raw
  .filter(p => p.z >= 800)
  .map(p => new THREE.Vector3(p.x + delta2.x, p.y + delta2.y, p.z + delta2.z));
let pedIndex  = 0, pedT  = 0;          // çµ¦ path  ç”¨
let pedIndex2 = 0, pedT2 = 0;
let pedestrianStopped2 = false;
let etaObject = null, etaFrozen2 = false;

const pivot = path[0].clone();    // ä»¥èµ·é»ç‚ºåœ“å¿ƒ
const pivot2 = path2[0].clone();    // ä»¥èµ·é»ç‚ºåœ“å¿ƒ

function rotatePath2(pathRef, angleRad, pivot) {
  return pathRef.map(p => {
    const v = p.clone().sub(pivot);                  // ä½ç§»åˆ°åŸé»
    v.applyAxisAngle(new THREE.Vector3(0,-3,0), angleRad); // Y è»¸æ—‹è½‰
    return v.add(pivot);                             // ç§»å›åŸæœ¬åŸºæº–
  });
}
function rotatePath(pathRef, angleRad, pivot) {
  return pathRef.map(p => {
    const v = p.clone().sub(pivot);                  // ä½ç§»åˆ°åŸé»
    v.applyAxisAngle(new THREE.Vector3(0,-1,0), angleRad); // Y è»¸æ—‹è½‰
    return v.add(pivot);                             // ç§»å›åŸæœ¬åŸºæº–
  });
}
const angle = Math.PI / 4;           // 45Â°

const rotated = rotatePath2(path, angle, pivot);
const rotated2 = rotatePath(path2, angle, pivot2);
for (let i = 0; i < path.length; i++) path[i].copy(rotated[i]);
for (let i = 0; i < path2.length; i++) path2[i].copy(rotated2[i]);

const offset2 = new THREE.Vector3(  4,   0,  15 );   // æƒ³å¾€ +X0.8ã€â€‘Z2.5 çš„æ–¹å‘å¹³ç§»
path2.forEach(p => p.add(offset2));                       // æŠŠä½ç§»å¥—åˆ°æ¯å€‹ç¯€é»
pivot.add(offset2);    
const offset1 = new THREE.Vector3(  4,   0,  0 );   // æƒ³å¾€ +X0.8ã€â€‘Z2.5 çš„æ–¹å‘å¹³ç§»
path.forEach(p => p.add(offset1));                       // æŠŠä½ç§»å¥—åˆ°æ¯å€‹ç¯€é»
pivot.add(offset1);  
/* -------- è·¯å¾‘ 3ï¼ˆX 241~262ï¼‰ -------- */
const targetStart3 = new THREE.Vector3(-3, 0.1, 10);   // â† æƒ³æ”¾ç¬¬ 3 è·¯ç·šçš„èµ·é»
const first3 = raw.find(p => p.x >= 241 && p.x <= 263); // æ‰¾åˆ°è½åœ¨å€é–“çš„ç¬¬ä¸€é»

const delta3 = new THREE.Vector3(
  targetStart3.x - first3.x,
  targetStart3.y - first3.y,
  targetStart3.z - first3.z
);

const path3 = raw
  .filter(p => p.x >= 241 && p.x <= 262)               // æŠŠ X è½åœ¨å€é–“çš„é»æŒ‘å‡º
  .map(p => new THREE.Vector3(p.x + delta3.x,
                              p.y + delta3.y,
                              p.z + delta3.z));
/* æ—‹è½‰ & ä½ç§»ï¼ˆè·Ÿå‰é¢ä½œæ³•å®Œå…¨ç›¸åŒï¼‰ ----------------- */
const pivot3  = path3[0].clone();
const rotated3 = rotatePath(path3, angle, pivot3);      // 40 è¡Œå‰å¾Œéƒ½å¯é‡ç”¨
for (let i = 0; i < path3.length; i++) path3[i].copy(rotated3[i]);

const offset3 = new THREE.Vector3( 2, 0, -3 );           // è¦ä¸è¦å†å¹³ç§»ï¼Œçœ‹éœ€æ±‚
path3.forEach(p => p.add(offset3));
pivot3.add(offset3);

/* å°æ‡‰çš„ç´¢å¼• / æ——æ¨™ ----------------------------- */
let pedIndex3  = 0, pedT3  = 0;
let etaThird   = null, etaFrozen3 = false;
let pedestrianStopped3 = false;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
   camera.position.set(20, 20, 20);
  camera.lookAt(-10, 0, 10);
//     camera.position.set(0, 50, 0);  // å‚ç›´ä¸Šæ–¹
// camera.lookAt(0, 0, 0);         // çœ‹å‘åœ°é¢ä¸­å¿ƒ
// camera.up.set(0, 0, -1);        // å°‡ Z è»¸ç•¶ä½œç•«é¢ä¸Šæ–¹


    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0xcccccc }));
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
// å»ºè­°æ”¾åœ¨ createMarkerã€drawPredictedPath ä¹‹ä¸Š
const forecastGroup = new THREE.Group();
scene.add(forecastGroup);

    const dangerArea = new THREE.Mesh(new THREE.BoxGeometry(1.75, 0.2, 4.63), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 }));
    scene.add(dangerArea);

    const collisionArea = new THREE.Mesh(new THREE.CircleGeometry(1, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 }));
    collisionArea.rotation.x = -Math.PI / 2;
    scene.add(collisionArea);

    const pedestrianPath = [], carPath = [], pedestriansFromObject = [], pedestriansWandering = [];
    pedestriansFromObject.push({ id: 'fromObject1', position: new THREE.Vector3(0, 0.1, 15), direction: new THREE.Vector3(1, 0, -1).normalize(), speed: 0.01});
    pedestriansWandering.push({ id: 'wanderer1', position: new THREE.Vector3(0, 0.1, 20), direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(), speed: 0.01, changeTimer: 0 });

    let isPlaying = false, selectedRoute = 'default', time = 0, carDistance = 0;
    let carSpeed = parseFloat(document.getElementById("speedInput").value);
const loader = new GLTFLoader();
let carModel;

loader.load('./model/toyota_corolla_altis_stance.glb', gltf => {
  carModel = gltf.scene;
  carModel.scale.set(0.01, 0.01, 0.01); // å…ˆç¸®å°çœ‹çœ‹
  carModel.position.set(2, 0.1, -30);   // èª¿é«˜ä¸€é»
  scene.add(carModel);
  console.log('è¼‰å…¥æˆåŠŸ', carModel);
}, undefined, error => {
  console.error('è¼‰å…¥è»Šè¼›æ¨¡å‹å¤±æ•—:', error);
});
/* === è·¯å¾‘è³‡æ–™ === */


const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 10, 10);
scene.add(light);

    const t_safety = 3.5, t_reaction = 1.5, a_brake = 8;

    document.getElementById('playBtn').onclick = () => isPlaying = true;
    document.getElementById('pauseBtn').onclick = () => isPlaying = false;
    document.getElementById('resetBtn').onclick = () => {
  // ğŸ” é‡è¨­æ•¸æ“šèˆ‡ç‹€æ…‹
  time = 0;
  carDistance = 0;
  carSpeed = parseFloat(document.getElementById("speedInput").value) || 0;
  braking = false;

  brakeTimer = 0;
  etaDefault = null;
  etaFrozen = false;
  initialSpeed = 0;
  window.pathShown = false;
  window.formulaShown = false;
  window.warnPlayed = false;
  window.resultShown = false;
  window.earlyWarnPlayed = false;

  // ğŸ§¹ æ¸…é™¤æ¨™è¨˜çƒ
  [...scene.children].forEach(obj => {
    if (obj.isMesh && obj.geometry.type === 'SphereGeometry') {
      scene.remove(obj);
    }
  });

  // ğŸ§â€â™‚ï¸ é‡è¨­è¡Œäººä½ç½®
  pedestriansFromObject[0].position.set(0, 0.1, 15);
  pedestriansWandering[0].position.set(0, 0.1, 20);
  pedestriansWandering[0].changeTimer = 0;

  // ğŸš— é‡è¨­è»Šè¼›ä½ç½®
  if (carModel) {
    carModel.position.set(1.25, 0.1, 2.5 - 50); // Z = -30 æ™‚çš„èµ·å§‹ä½ç½®
  }

  // ğŸ“‰ é‡è¨­ HUD é¡¯ç¤º
  document.getElementById('timeDisplay').innerText = `æ¨¡æ“¬ç§’æ•¸: 0.00s`;
  document.getElementById('speedHUD').innerText = `é€Ÿåº¦: ${(carSpeed * 3.6).toFixed(1)}â€¯km/h`;
  document.getElementById("etaDisplay").innerText = "é ä¼°é€²å…¥è­¦ç¤ºå€åŸŸæ™‚é–“: -- s";
  document.getElementById("brakeDisplay").innerHTML = `ç¸½ç…åœè·é›¢: -- m<br>ç¸½ç…åœæ™‚é–“: -- s`;

  // ğŸ”• æ¸…é™¤è­¦å‘Šèˆ‡ç´…æ¡†
  document.getElementById("warning").style.display = "none";
  document.getElementById("warning").innerText = "";
  document.getElementById('redFrame').style.borderColor = 'rgba(255,0,0,0)';

  // ğŸ“Š æ¸…é™¤çµæœé¡¯ç¤º
  ['formulaHUD', 'resultHUD'].forEach(id => {
    const e = document.getElementById(id);
    e.style.display = 'none';
    e.innerHTML = '';
  });
stopFlashingRedFrame();      // â† æ–°å¢
  // âœ… æ¨¡æ“¬ç‹€æ…‹æš«åœ
  isPlaying = false;
};



    document.getElementById('setSpeedBtn').onclick = () => {
      const inputVal = parseFloat(document.getElementById("speedInput").value);
      if (!isNaN(inputVal) && inputVal >= 0) carSpeed = inputVal;
    };

    document.querySelectorAll('input[name="pedestrianRoute"]').forEach(r => {
  r.addEventListener('change', e => {
    selectedRoute = e.target.value;
etaDefault = null;
etaFrozen = false;

    // é‡è¨­æ¨¡æ“¬æ™‚é–“èˆ‡è»Šè·
    time = carDistance = 0;

    // é‡è¨­è¡Œäººä½ç½®
    pedestriansFromObject[0].position.set(0, 0.1, 15);
    pedestriansWandering[0].position.set(0, 0.1, 20);
    pedestriansWandering[0].changeTimer = 0;

    // æ¸…é™¤æ¨™è¨˜çƒ
    [...scene.children].forEach(obj => {
      if (obj.isMesh && obj.geometry.type === 'SphereGeometry') {
        scene.remove(obj);
      }
    });

    // æ¸…ç©ºè»Œè·¡
    pedestrianPath.length = 0;
    carPath.length = 0;

    // é‡è¨­æ™‚é–“é¡¯ç¤ºèˆ‡è­¦ç¤º
    document.getElementById('timeDisplay').innerText = `æ¨¡æ“¬ç§’æ•¸: 0.00s`;
    document.getElementById("warning").style.display = "none";
  });
});


    function createMarker(x, y, z, color = 0xffff00) {
      const marker = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshBasicMaterial({ color }));
      marker.position.set(x, y, z);
      scene.add(marker);
    }

    function isInsideEllipse(px, pz, cx, cz, rx, rz) {
      const dx = px - cx, dz = pz - cz;
      return (dx * dx) / (rx * rx) + (dz * dz) / (rz * rz) <= 1;
    }

    function isInsideBox(px, pz, cx, cz, hx, hz) {
      return Math.abs(px - cx) <= hx && Math.abs(pz - cz) <= hz;
    }
// function drawPredictedPath(startPos, direction, speed,
//                            duration = 4, interval = 0.2) {
//   // â‘  æ¸…æ‰ä¸Šä¸€å¹€ç•™ä¸‹çš„çƒ
//   forecastGroup.clear();

//   // â‘¡ é€æ ¼ç”¢ç”Ÿæ–°çƒ
//   for (let t = 0; t <= duration + 4; t += interval) {
//     const pos = startPos.clone().addScaledVector(direction, speed * t);

//     // ç¶ â†’ç´…æ¼¸è®Š
//     const color = new THREE.Color().setHSL((1 - t / duration) * 0.33, 1, 0.5);

//     const marker = new THREE.Mesh(
//       new THREE.SphereGeometry(0.1, 8, 8),
//       new THREE.MeshBasicMaterial({ color })
//     );
//     marker.position.copy(pos);
//     forecastGroup.add(marker);      // â† å¡é€² group è£¡
//   }
// }

function drawNextWaypoints(idx, pathRef, count = 4) {
  forecastGroup.clear();
  for (let k = 1; k <= count; k++) {
    const i = idx + k;
    if (i >= pathRef.length) break;
    const pos = pathRef[i];
    const hue = (count - k) / count * 0.33;
    const marker = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 8, 8),
      new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.5) })
    );
    marker.position.copy(pos);
    forecastGroup.add(marker);
  }
}



    function getColorBySpeed(speed) {
  if (speed < 10) return '#00ffff'; // é’è‰²
  if (speed < 20) return '#00ff00'; // ç¶ 
  if (speed < 30) return '#ffff00'; // é»ƒ
  if (speed < 40) return '#ffa500'; // æ©˜
  if (speed < 50) return '#ff0000'; // ç´…
  return '#8b0000'; // æ·±ç´…
}
function computeETAtoEllipse(pedPos, pedDir, pedSpeed, ellipseCenter, ellipseA, ellipseB) {
  const dx = pedPos.x - ellipseCenter.x;
  const dz = pedPos.z - ellipseCenter.z;
  const vx = pedDir.x * pedSpeed;
  const vz = pedDir.z * pedSpeed;

  const A = (vx * vx) / (ellipseA * ellipseA) + (vz * vz) / (ellipseB * ellipseB);
  const B = 2 * ((dx * vx) / (ellipseA * ellipseA) + (dz * vz) / (ellipseB * ellipseB));
  const C = (dx * dx) / (ellipseA * ellipseA) + (dz * dz) / (ellipseB * ellipseB) - 1;

  const discriminant = B * B - 4 * A * C;

  if (discriminant < 0 || A === 0) return null;

  const sqrtD = Math.sqrt(discriminant);
  const t1 = (-B - sqrtD) / (2 * A);
  const t2 = (-B + sqrtD) / (2 * A);

  const tEntry = Math.min(t1, t2);
  if (tEntry >= 0) return tEntry;
  if (Math.max(t1, t2) >= 0) return 0; // å·²é€²å…¥æ©¢åœ“
  return null; // ä¸æœƒé€²å…¥
}
let etaDefault = null;     // é è¨­è¡Œäºº ETA
let etaFrozen = false;     // æ˜¯å¦å·²ç¶“é€²å…¥éæ©¢åœ“ â†’ é–å®š ETA
const SAFE_DIST = 2; // å®‰å…¨è·é›¢é–¾å€¼ (å–®ä½ï¼šå…¬å°º)
let initialSpeed = 0;  // ç´€éŒ„å‰è»Šç•¶ä¸‹çš„åŸå§‹é€Ÿåº¦
const EPS = 0.05;      // æ¥è¿‘éœæ­¢çš„é€Ÿåº¦é–¾å€¼ (m/s)
/* === æ’­æ”¾åƒæ•¸ === */

const segDt  = 0.2;    // æ¯æ®µèŠ±å¤šå°‘ç§’èµ°éï¼ˆå¯èª¿ï¼‰
const dt     = 0.01;   // animate() æ¯å¹€æ™‚é–“å¢é‡

let braking = false;       // æ˜¯å¦æ­£åœ¨å‰è»Š
let pedestrianStopped = false; // <-- è¡Œäººæ˜¯å¦å·²åœæ­¢
let brakeTimer = 0;        // å‰è»Šè¨ˆæ™‚å™¨
/* ====== 1. å–ä»£ flashRedFrameï¼šæŒçºŒé–ƒçˆ ====== */
let redFrameFlashId = null;   // é–ƒçˆè¨ˆæ™‚å™¨ id

function startFlashingRedFrame() {
  if (redFrameFlashId !== null) return;        // å·²åœ¨é–ƒ
  const frame = document.getElementById('redFrame');
  let visible = false;
  redFrameFlashId = setInterval(() => {
    frame.style.borderColor = visible ? 'rgba(255,0,0,0)'
                                      : 'rgba(255,0,0,1)';
    visible = !visible;
  }, 150);   // 0.15â€¯s äº¤æ›¿
}

function stopFlashingRedFrame() {
  const frame = document.getElementById('redFrame');
  if (redFrameFlashId !== null) {
    clearInterval(redFrameFlashId);
    redFrameFlashId = null;
  }
  frame.style.borderColor = 'rgba(255,0,0,0)'; // æ¢å¾©é€æ˜
}


const pedInit  = new THREE.Vector3(0, 0.1, 20);
const pedTarget= new THREE.Vector3( 4, 0.1,   0);
const pedDir   = new THREE.Vector3().subVectors(pedTarget, pedInit).normalize();
const pedSpeed = 2.5;         
  let isPedestrianInEllipse = false;
function animate() {
  requestAnimationFrame(animate);
isPedestrianInEllipse = false;

  if (!isPlaying) return renderer.render(scene, camera);
console.log(isPlaying);
  time += 0.01;
  document.getElementById('timeDisplay').innerText = `æ¨¡æ“¬ç§’æ•¸: ${time.toFixed(2)}s`;
const carX = 5;
   let carZ = time < 0.01 ? -90 : -90 + carDistance;
  const warningDiv = document.getElementById("warning");
  warningDiv.style.display = "none";

  
  // å¦‚æœå‰è»Šä¸­ï¼Œé€Ÿåº¦é€æ¼¸æ¸›å°‘
  if (braking) {
  brakeTimer += 0.01;

  if (brakeTimer >= t_reaction) {
    const t_brake = brakeTimer - t_reaction;
    carSpeed = Math.max(0, initialSpeed - a_brake * t_brake);  // âœ… ç·šæ€§æ¸›é€Ÿ
  }

  if (carSpeed <= EPS) {   // ç…åœå®Œæˆ
  carSpeed = 0;
  isPlaying = false;
  warningDiv.innerText = "ç…è»Šå®Œæˆ";
  warningDiv.style.background = "red";
  warningDiv.style.display = "block";

  // åœæ­¢ beep éŸ³æ•ˆ
  const beepAudio = document.getElementById('beepSfx');
  beepAudio.pause();
  beepAudio.currentTime = 0;

  const voiceAudio = document.getElementById('voiceSfx');
  voiceAudio.pause();
  voiceAudio.currentTime = 0;
  // åœæ­¢ç´…æ¡†é–ƒçˆ
  stopFlashingRedFrame();

  if (!window.resultShown) {
    window.resultShown = true;

  }

  return;
}

}


 

  carDistance += carSpeed * 0.01;
 
  if (carModel) {
  carModel.position.set(4.25, 0.1, 2.5+carZ);  // æ ¹æ“šè»Šé€Ÿæ›´æ–° Z åº§æ¨™
}
document.getElementById('speedHUD').innerText =
  `é€Ÿåº¦: ${(carSpeed * 3.6).toFixed(1)}â€¯km/h`;

  const safeDistance = carSpeed * t_safety + (carSpeed * carSpeed) / (2 * a_brake);
  const scaleZ = Math.max(1, safeDistance); 

  collisionArea.scale.set(1, scaleZ, 1);
  collisionArea.position.set(carX, 0.05, carZ);
  dangerArea.position.set(carX, 0.1, carZ);
  collisionArea.material.color.set(getColorBySpeed(carSpeed));

  // åˆ¤æ–·æ˜¯å¦æœ‰è¡Œäººé€²å…¥æ©¢åœ“å€ï¼Œè§¸ç™¼å‰è»Š


  // ä½ åŸæœ¬çš„åˆ¤æ–·ç¨‹å¼è£¡ï¼Œè«‹æŠŠã€Œæ©¢åœ“å€åˆ¤æ–·ã€æ”¹æˆä¸‹é¢çš„åŒæ™‚è¨­å®šè®Šæ•¸
  function checkPedestrian(x, z) {
    if (isInsideEllipse(x, z, carX, carZ, 1, scaleZ)) {
      isPedestrianInEllipse = true;
      return true;
    }
    return false;
  }


if (selectedRoute === 'default' && path.length >= 2) {
  // 1. ç›®å‰æ®µ p0â†’p1
  var p0 = path[pedIndex];
  var p1 = path[Math.min(pedIndex + 1, path.length - 1)];

  // 2. ä¾æ™‚é–“å…§æ’
if (!pedestrianStopped) {
    pedT += dt / segDt;
    if (pedT >= 1) {
      pedT = 0;
      if (pedIndex < path.length - 2) pedIndex++;
    }
  }
const pedPos = p0.clone().lerp(p1, pedT);   // ä½ åŸæœ¬ç”¨ä¾†ç•«è¡Œäººçš„åº§æ¨™
currPedPos.copy(pedPos);    
  // 3. å³æ™‚æ–¹å‘ / é€Ÿåº¦ï¼ˆçµ¦ ETA & å‰è»Šå…¬å¼ï¼‰
  const pedDir   = p1.clone().sub(p0).normalize();
  const pedSpeed = p0.distanceTo(p1) / segDt;   // m/s

  // 4. ä½ ä¹‹å‰çš„æµç¨‹ï¼šæ¨™è¨˜çƒã€ETA è¨ˆç®—ã€è­¦ç¤ºé¡¯ç¤º
  createMarker(pedPos.x, pedPos.y, pedPos.z, 0xff0000);

if (!etaFrozen) {
   const etaCalc = computeETAtoEllipse(
     pedPos, pedDir, pedSpeed,
     new THREE.Vector3(carX, 0, carZ), 1, scaleZ
   );

   /* åªæœ‰é‚„åœ¨æ©¢åœ“å¤–(>0)æ™‚æ‰æ›´æ–°ç•«é¢ä¸Šçš„ t_entry */
   if (etaCalc > 0) {
     etaDefault = etaCalc;      // ä¿ç•™æœ€å¾Œä¸€æ¬¡æ­£å€¼
   } else {
    etaDefault = 0;
     etaFrozen = true;          // è¸é€²æ©¢åœ“ â†’ é–å®š
   }
 }
//     if (isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ)) {
//      pedestrianStopped = true;
//    }
  document.getElementById("etaDisplay").innerText =
    `é ä¼°é€²å…¥è­¦ç¤ºå€åŸŸæ™‚é–“: ${etaDefault !== null
        ? etaDefault.toFixed(2) + 'Â s' : '--'}`;
// 1ï¸âƒ£ å…ˆç›´æ¥è¨ˆç®—
const inEllipse = isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ);

isPedestrianInEllipse = inEllipse;   // çµ¦å‰è»Šé‚è¼¯ç”¨

// 2ï¸âƒ£ ç„¶å¾Œåˆ¤æ–·é¡¯ç¤ºæ–‡å­—
if (isInsideBox(pedPos.x, pedPos.z, carX, carZ, 1, 1)) {
  warningDiv.innerText = "ç™¼ç”Ÿè»Šç¦";
  warningDiv.style.background = "red";
  warningDiv.style.display = "block";
  isPlaying = false;
  return;
} else if (inEllipse) {

  warningDiv.innerText = "é€²å…¥è­¦ç¤ºå€";
  warningDiv.style.background = "orange";
  warningDiv.style.display = "block";
    document.getElementById('beepSfx').play();
    document.getElementById('voiceSfx').play();
}
 
}

/* === B. object è·¯ç·šï¼šx 221â€“228 ä¹‹é–“ === */
if (selectedRoute === 'object' && path2.length >= 2) {


  /* â‘  è·¯å¾‘ç´¢å¼•ï¼å…§æ’ç”¨çš„è®Šæ•¸å…¨éƒ¨æ›æˆ pedIndex2 / pedT2 */
  var q0 = path2[pedIndex2];
  var q1 = path2[Math.min(pedIndex2 + 1, path2.length - 1)];

  if (!pedestrianStopped2) {              // â‘¡ åœæ­¢æ——æ¨™ä¹Ÿåˆ†é–‹
    pedT2 += dt / segDt;
    if (pedT2 >= 1) {
      pedT2 = 0;
      if (pedIndex2 < path2.length - 2) pedIndex2++;
    }
  }

  const pedPos = q0.clone().lerp(q1, pedT2);
  currPedPos.copy(pedPos);

  const pedDir   = q1.clone().sub(q0).normalize();
  const pedSpeed = q0.distanceTo(q1) / segDt;

  /* â‘¢ æ›è‰²çƒï¼æ¨™è¨˜åŒç”¨ */
  createMarker(pedPos.x, pedPos.y, pedPos.z, 0x00ffff); // â† é¡è‰²çµ¦ cyanï¼Œæ–¹ä¾¿å€åˆ†

  /* â‘£ ETA èˆ‡é–å®šæ——æ¨™ä¹Ÿåˆ†å‡º object ç‰ˆæœ¬ */
  if (!etaFrozen2) {
    const etaCalc = computeETAtoEllipse(
      pedPos, pedDir, pedSpeed,
      new THREE.Vector3(carX, 0, carZ), 1, scaleZ
    );

    if (etaCalc > 0) {
      etaObject = etaCalc;
    } else {
      etaObject = 0;
      etaFrozen2 = true;
    }
  }

  //  if (isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ)) {
  //    pedestrianStopped2 = true;
  //  }

  document.getElementById("etaDisplay").innerText =
    `é ä¼°é€²å…¥è­¦ç¤ºå€åŸŸæ™‚é–“: ${etaObject !== null
        ? etaObject.toFixed(2) + ' s' : '--'}`;

  const inEllipse = isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ);
  isPedestrianInEllipse = inEllipse;

  if (isInsideBox(pedPos.x, pedPos.z, carX, carZ, 1, 1)) {
    warningDiv.innerText = "ç™¼ç”Ÿè»Šç¦ (object)";
    warningDiv.style.background = "red";
    warningDiv.style.display = "block";
    isPlaying = false;
    return;
  } else if (inEllipse) {
    warningDiv.innerText = "é€²å…¥è­¦ç¤ºå€ (object)";
    warningDiv.style.background = "orange";
    warningDiv.style.display = "block";
    document.getElementById('beepSfx').play();
    document.getElementById('voiceSfx').play();
  }
}/* === C. wander è·¯ç·šï¼šx 241â€“262 ä¹‹é–“ === */
if (selectedRoute === 'wander' && path3.length >= 2) {

  var r0 = path3[pedIndex3];
  var r1 = path3[Math.min(pedIndex3 + 1, path3.length - 1)];

  if (!pedestrianStopped3) {
    pedT3 += dt / segDt;
    if (pedT3 >= 1) {
      pedT3 = 0;
      if (pedIndex3 < path3.length - 2) pedIndex3++;
    }
  }

  const pedPos = r0.clone().lerp(r1, pedT3);
  currPedPos.copy(pedPos);

  const pedDir   = r1.clone().sub(r0).normalize();
  const pedSpeed = r0.distanceTo(r1) / segDt;

  createMarker(pedPos.x, pedPos.y, pedPos.z, 0x00ff00); // lime ç¶ 

  if (!etaFrozen3) {
    const etaCalc = computeETAtoEllipse(
      pedPos, pedDir, pedSpeed,
      new THREE.Vector3(carX, 0, carZ), 1, scaleZ
    );

    if (etaCalc > 0)  etaThird = etaCalc;
    else { etaThird = 0; etaFrozen3 = true; }
  }

  document.getElementById("etaDisplay").innerText =
    `é ä¼°é€²å…¥è­¦ç¤ºå€åŸŸæ™‚é–“: ${etaThird !== null
       ? etaThird.toFixed(2) + ' s' : '--'}`;

  const inEllipse = isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ);
  isPedestrianInEllipse = inEllipse;
// if (isInsideEllipse(pedPos.x, pedPos.z, carX, carZ, 1, scaleZ)) {
//      pedestrianStopped3 = true;
//    }
  if (isInsideBox(pedPos.x, pedPos.z, carX, carZ, 1, 1)) {
    warningDiv.innerText = "ç™¼ç”Ÿè»Šç¦ (wander)";
    warningDiv.style.background = "red";
    warningDiv.style.display = "block";
    isPlaying = false;
    return;
  } else if (inEllipse) {
    warningDiv.innerText = "é€²å…¥è­¦ç¤ºå€ (wander)";
    warningDiv.style.background = "orange";
    warningDiv.style.display = "block";
    document.getElementById('beepSfx').play();
    document.getElementById('voiceSfx').play();
  }
}




  // è§¸ç™¼å‰è»Šæ¢ä»¶
if (isPedestrianInEllipse && !braking) {

  const reactionDistance = carSpeed * t_reaction;
  const brakeDistance = (carSpeed * carSpeed) / (2 * a_brake);
  const totalDistance = reactionDistance + brakeDistance;

  const totalTime = t_reaction + (carSpeed / a_brake);

  document.getElementById("brakeDisplay").innerHTML =
    `ç¸½ç…åœè·é›¢: ${totalDistance.toFixed(2)} m<br>ç¸½ç…åœæ™‚é–“: ${totalTime.toFixed(2)} s`;
    braking = true;  // é€™è£¡ä¸€å®šè¦åŠ ï¼Œä¸ç„¶å‰è»Šä¸æœƒé–‹å§‹
  brakeTimer = 0;  // å»ºè­°é‡ç½®å‰è»Šè¨ˆæ™‚å™¨
  initialSpeed = carSpeed;  // ç´€éŒ„ç•¶ä¸‹é€Ÿåº¦
}

/* ---------- 1.0 sï¼šé¡¯ç¤ºé æ¸¬è»Œè·¡ ---------- */
/* === 1. é¡¯ç¤ºé æ¸¬è»Œè·¡ï¼šç¬¬ä¸€æ¬¡æ‹¿åˆ° etaDefault å°±ç•« === */



/* === 2. å…¬å¼ HUDï¼šç¬¬ä¸€æ¬¡ç®—å‡º etaDefault æ™‚å°±æ‰“é–‹ === */
if (etaDefault !== null) {
  if (!window.formulaShown) {
    window.formulaShown = true;
    document.getElementById('formulaHUD').style.display = 'block';
    // å›ºå®š t_stopï¼Œåªç®—ä¸€æ¬¡
    window.tStopConst = t_reaction + carSpeed / a_brake;
  }

  const div = document.getElementById('formulaHUD');
  div.innerHTML =
    `t_entryï¼ˆå‰©é¤˜ï¼‰= ${etaDefault.toFixed(2)}â€¯s<br>` +
    `tè­¦ç¤ºï¼ˆåæ‡‰+ç…åœï¼‰= ${window.tStopConst.toFixed(2)}â€¯s<br>` +
    `Î” = ${(etaDefault - window.tStopConst).toFixed(2)}â€¯s`;

  /* ä¾†ä¸åŠå‰åœå°±ç«‹å³è§¸ç™¼è­¦ç¤º */
if (
    time > 0.3 && 
  etaDefault !== null &&
  etaDefault > 0.05 &&
  etaDefault < window.tStopConst &&
  !window.earlyWarnPlayed 
) { 

  startFlashingRedFrame();
  window.earlyWarnPlayed = true;
  braking = true;
  brakeTimer = 0;
initialSpeed = carSpeed; 

}

}

/* === 3. çµæœé¡¯ç¤ºï¼šè»Šå­åœä¸‹ or ç¢°æ’ å°±åˆ¤å®š === */
if (!window.resultShown && (braking && carSpeed === 0 )) {
  window.resultShown = true;
  const ok = etaDefault >= window.tStopConst;   // å‰å¾—åŠ = æˆåŠŸ
  const div = document.getElementById('resultHUD');
  div.style.background = ok ? 'rgba(0,128,0,.8)' : 'rgba(128,0,0,.8)';
  div.innerText = ok ? 'âœ… æˆåŠŸé¿å…ç¢°æ’' : 'âŒ ä»æœ‰å±éšª';
  div.style.display = 'block';
  isPlaying = false;          // å‡çµç•«é¢
  return;
}

let pedPosForHUD;
let idxForWaypoints;
let pathForWaypoints;

if (selectedRoute === 'default') {
  pedPosForHUD      = p0.clone().lerp(p1, pedT);
  idxForWaypoints   = pedIndex;
  pathForWaypoints  = path;
} else if (selectedRoute === 'object') {
  pedPosForHUD      = q0.clone().lerp(q1, pedT2);
  idxForWaypoints   = pedIndex2;
  pathForWaypoints  = path2;
}else if (selectedRoute === 'wander') {
  pedPosForHUD     = r0.clone().lerp(r1, pedT3);
  idxForWaypoints  = pedIndex3;
  pathForWaypoints = path3;
}

// â”€â”€ è·é›¢ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const carPos = new THREE.Vector3(carX, 0.1, carZ);
const dist   = pedPosForHUD.distanceTo(carPos);
resultHUD.style.background = dist > SAFE_DIST ? 'rgba(0,128,0,.8)' : 'rgba(128,0,0,.8)';
resultHUD.innerText = dist > SAFE_DIST ?
  `âœ… ç…è»Šå®Œæˆ â€¢ å®‰å…¨è·é›¢ ${dist.toFixed(2)}â€¯m` :
  `âŒ å±éšªï¼è·é›¢åªæœ‰ ${dist.toFixed(2)}â€¯m`;
resultHUD.style.display = 'block';

// â”€â”€ 4â€‘é»é æ¸¬çƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
drawNextWaypoints(idxForWaypoints, pathForWaypoints);


/* ====== 2. åœ¨ animate() è¿´åœˆå°¾ç«¯çµ±ä¸€æ§åˆ¶ ====== */
// é€™æ®µæ”¾åœ¨ animate() æœ€å¾Œä¸€è¡Œã€å‘¼å« renderer å‰é¢

if (warningDiv.style.display === "block") {
  startFlashingRedFrame();     // ç›®å‰æœ‰è­¦ç¤º â†’ ä¿æŒé–ƒçˆ
} else {
  stopFlashingRedFrame();      // æ²’æœ‰è­¦ç¤º â†’ é—œæ‰é–ƒçˆ
}

  renderer.render(scene, camera);
}

    animate();
  </script>
</body>
</html>
